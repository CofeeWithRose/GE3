<!DOCTYPE html>
<html>

<head>
	<style>
		html,
		body {
			margin: 0;
			padding: 0;
			width: 100%;
			height: 100%;
		}
		.input{
			width: 100px;
			height: 15px;
			margin: auto;
		}
		canvas{
			border: gray solid 1px;
			border-radius: 10PX;
		}
	</style>
	<script type="text/javascript" src="findPath2.js" charset="utf-8"></script>
	<title>findPath</title>
</head>

<body onmouseup="endDrag()">
	<div style="display:flex;">
		<!-- <div style="width: 80%;display:flex;margin: auto;"></div> -->
		<canvas id="canvas" style="margin: auto;" onmousemove="drag(event)" onmousedown="startDrag(event)"></canvas>
		<div class="input">
			startPoint <input type="input" name="" value="0" onkeyup="drawCanvas()" />
			endPoint <input type="input" name="" value="7" onkeyup="drawCanvas()" />
		</div>	
	</div>
	
	
</body>
</body>
</body>
<script>
	var inputs = document.querySelectorAll("input");
	var stInput = inputs[0];
	var endInput = inputs[1];
	var lastSt;
	var lastEnd;
	var canvas = document.getElementById("canvas");
	canvas.width = 600;
	canvas.height = 600;
	var context = canvas.getContext("2d");
	

	//构造地图.A-H点，两两相连，默认为静态点.
	var map = new PD.MapData();

	var pointA = new PD.Vectort2(1, 0, true);
	var pointB = new PD.Vectort2(2, 0,true);
	var pointC = new PD.Vectort2(1, 2,true);
	var pointD = new PD.Vectort2(2, 2,true);
	var pointE = new PD.Vectort2(0, 2,true);
	var pointF = new PD.Vectort2(0, 3,true);
	var pointG = new PD.Vectort2(3, 3,true);
	var pointH = new PD.Vectort2(3, 2,true);
	var list = [pointA, pointB, pointC, pointD, pointE, pointF, pointG, pointH];

	for (var i = 0; i < list.length - 1; i++) {
		for (var j = i + 1; j < list.length - 1; j++) {
			//双向互通
			map.add(new PD.Segment(list[i], list[j]));
			map.add(new PD.Segment(list[j], list[i]));
		}
	}
	map.add(new PD.Segment(list[5], list[7]));
	map.add(new PD.Segment(list[7], list[1]));
	map.add(new PD.Segment(list[6], list[7]));

	
	
	//绘图.
	function marPoint(node, R,color) {
		context.beginPath();
		var n = fixPosition(node);
		context.arc(n.x, n.y, R, 0, 2 * Math.PI, true);
		context.fillStyle = color||"gray";
		context.fill();
		if (!isNaN(node.id)) {
			context.fillStyle = "blue";
			context.font = "20px Georgia";
			context.fillText(node.id, n.x - 20, n.y - 20);
		}
		context.stroke();
		context.closePath();
	};
	function fixPosition(node) {
		return { x: 150 + node.x * 100, y: 100 + 100 * node.y };
	};
	function reFixPosition(point){
		 return { x: -150 + node.x * 0.01, y: -100 + 0.01 * node.y };
	}

	function linePoint(nodeA, nodeB, linecloor, width) {
		context.beginPath();
		context.strokeStyle = linecloor || "black";
		context.lineWidth = width || 1;
		var a = fixPosition(nodeA);
		var b = fixPosition(nodeB);
		context.moveTo(a.x, a.y);
		context.lineTo(b.x, b.y);
		context.stroke();
		context.closePath();

		var v = { x: nodeB.x - nodeA.x, y: nodeB.y - nodeA.y };
		var vl = Math.sqrt(v.y * v.y + v.x * v.x);
		var st = { x: nodeA.x + v.x * 0.5, y: nodeA.y + v.y * 0.5 };
		marPoint(st, 3);
		marPoint({ x: st.x + 0.05 / vl * v.x, y: st.y + 0.05 / vl * v.y }, 1);
	};

	function drawCanvas(){
		var st = stInput.value||lastSt;
		var end = endInput.value||lastEnd;
        context.clearRect(0,0,600,600);
		console.time("getMinpath: ");
		//获取路径最短.
		var nodes = PD.findPath(list[st],list[end], map);
		console.timeEnd("get min path: ");

		for (var key in map.segmentMap) {
			var s = map.segmentMap[key];
			linePoint(s.nodeA, s.nodeB, 'gray');
			
		}
		// context.save();
		for (var i = 0; i < list.length; i++) {
			marPoint(list[i], 10);
		}
		//绘制最短路径.
		for (var i = 0; i < nodes.length - 1; i++) {
			linePoint(nodes[i], nodes[i + 1], "red", 2);
		}
		lastSt = st;
		lastEnd = end;
	};
drawCanvas();
var mousePoint={x:0,y:0};
var selectedPoint;
function startDrag(e){
	mousePoint.x=e.offsetX;
	mousePoint.y=e.offsetY;
	mousePoint = reFixPosition(mousePoint);
	for (let index = 0; index < list.length; index++) {
		const ele = list[index];
		
	}
}
function endDrag(){
	selectedPoint = undefined;
	drawCanvas();
}
function drag(e){

	if(selectedPoint){

		mousePoint.x=e.offsetX;
		mousePoint.y=e.offsetY;
		mousePoint = reFixPosition(mousePoint);
		selectedPoint.x = mousePoint.x;
		selectedPoint.y = mousePoint.y;
		drawCanvas();
	}


	console.log(mousePoint);
}
</script>

</html>